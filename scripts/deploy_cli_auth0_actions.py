import requests
import os
import json
import time


# load rule set
def load_action(filename):
  with open(f"actions/{filename}", "r") as f:
    action_script = f.read()
    return action_script


def generate_binding(action_name):
  return {
    "ref": {
      "type": "action_name",
      "value": action_name
    },
    "display_name": action_name,
  }


def fail_on_error(response):
  if response.status_code != 200:
    if 'message' in response.json():
      raise RuntimeError(
        f"Failed to deploy action: {response.status_code} {response.json()['message']}")
    else:
      raise RuntimeError(
        f"Failed to deploy action: {response.status_code}")



# ===== start

# fetch existing actions for the current tenant
# read access_token from ephemeral (generated by pipeline) file
with open('access_token', 'r') as file:
  auth_token = file.read().rstrip()

# request parameters
header = {"Authorization": f"Bearer {auth_token}"}
url = f"https://{os.environ.get('TENANT')}.us.auth0.com/api/v2/actions"
get_actions_response = requests.get(f"{url}/actions", headers=header)
existing_actions = get_actions_response.json()["actions"]
existing_actions_names = [action["name"] for action in existing_actions]

actions = json.load(open(f"actions/{os.environ.get('TENANT_APPLICATION')}-actions.json"))

for action in actions:
  action["code"] = load_action(action['script_filename'])
  action["secrets"] = [
    {
      "name": "clientId",
      "value": os.environ.get("TENANT_CLIENT_ID")
    },
    {
      "name": "clientSecret",
      "value": os.environ.get("TENANT_CLIENT_SECRET")
    }
  ]
  del action['script_filename']

  # create or patch action
  if action['name'] in existing_actions_names:
    for existing_action in existing_actions:
      if action['name'] == existing_action['name']:
        update_action_response = requests.patch(f"{url}/actions/{existing_action['id']}", headers=header,
                                                json=action)
  else:
    update_action_response = requests.post(f"{url}/actions", headers=header, json=action)
  fail_on_error(update_action_response)

  # deploy action
  action_id = update_action_response.json()["id"]
  deploy_action_response = requests.post(f"{url}/actions/{action_id}/deploy", headers=header, json=action)
  retries = 0
  while retries < 5 and deploy_action_response.status_code != 200:
    retries += 1
    time.sleep(1)
    deploy_action_response = requests.post(f"{url}/actions/{action_id}/deploy", headers=header, json=action)
  fail_on_error(deploy_action_response)

# bind actions to post-login trigger
bindings = {"bindings": [generate_binding(action["name"]) for action in actions]}
deploy_bindings_response = requests.patch(f"{url}/triggers/post-login/bindings", headers=header, json=bindings)

fail_on_error(deploy_bindings_response)
